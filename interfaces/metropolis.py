import numpy as np
import matplotlib.pyplot as plt
from typing import Optional, Callable, Union
from .target import TargetDistribution
from .target_torch import TorchTargetDistribution

class MHAlgorithm:
    """General purpose Metropolis-Hastings algorithm interface for sampling from a target distribution.

    This class is designed to be subclassed to implement specific calculations for the acceptance probability.
    The step method must be implemented in the subclass.
    
    The chain attribute stores the Markov chain of samples generated by the algorithm.
    The current state of the algorithm is the last element of the chain.
    """
    def __init__(self, dim, var, target_dist: Union[TargetDistribution, TorchTargetDistribution] = None, symmetric=True):
        self.dim = dim
        self.var = var
        self.target_dist = target_dist
        
        # iid Beta: Check for Beta distribution to initialize within (0.1, 0.9) domain
        if hasattr(target_dist, 'name') and isinstance(target_dist.name, str) and "Beta" in target_dist.name:
            # Initialize within (0.1, 0.9) to be safely away from boundaries
            initial_point = np.random.uniform(0.2, 0.8, size=dim).astype(np.float32)
            self.chain = [initial_point]
        elif hasattr(target_dist, 'get_name') and callable(target_dist.get_name) and isinstance(target_dist.get_name(), str) and "Beta" in target_dist.get_name():
            # Alternative check if name is a method
            initial_point = np.random.uniform(0.2, 0.8, size=dim).astype(np.float32)
            self.chain = [initial_point]
        
        # iid Gamma: Check for Gamma distribution to initialize within 5 + noise domain
        elif hasattr(target_dist, 'name') and isinstance(target_dist.name, str) and "Gamma" in target_dist.name:
            initial_point = 5 + 0.01 * np.random.randn(dim)
            self.chain = [initial_point]
        elif hasattr(target_dist, 'get_name') and callable(target_dist.get_name) and isinstance(target_dist.get_name(), str) and "Gamma" in target_dist.get_name():
            initial_point = 5 + 0.01 * np.random.randn(dim)
            self.chain = [initial_point]
        
        # Multimodal: Check for multimodal distribution to initialize at 0
        elif hasattr(target_dist, 'name') and isinstance(target_dist.name, str) and "RoughCarpet" in target_dist.name:
            initial_point = np.zeros(dim)
            self.chain = [initial_point]
        elif hasattr(target_dist, 'get_name') and callable(target_dist.get_name) and isinstance(target_dist.get_name(), str) and "RoughCarpet" in target_dist.get_name():
            initial_point = np.zeros(dim)
            self.chain = [initial_point]
        elif hasattr(target_dist, 'name') and isinstance(target_dist.name, str) and "ThreeMixture" in target_dist.name:
            initial_point = np.zeros(dim)
            self.chain = [initial_point]
        elif hasattr(target_dist, 'get_name') and callable(target_dist.get_name) and isinstance(target_dist.get_name(), str) and "ThreeMixture" in target_dist.get_name():
            initial_point = np.zeros(dim)
            self.chain = [initial_point]
        
        # Hypercube: initialize within (0.1, 0.9) domain
        elif hasattr(target_dist, 'name') and isinstance(target_dist.name, str) and "Gamma" in target_dist.name:
            # Initialize within (0.1, 0.9) to be safely away from boundaries
            initial_point = np.random.uniform(0.2, 0.8, size=dim).astype(np.float32)
            self.chain = [initial_point]
        elif hasattr(target_dist, 'get_name') and callable(target_dist.get_name) and isinstance(target_dist.get_name(), str) and "Gamma" in target_dist.get_name():
            # Initialize within (0.1, 0.9) to be safely away from boundaries
            initial_point = np.random.uniform(0.2, 0.8, size=dim).astype(np.float32)
            self.chain = [initial_point]
        
        else:
            self.chain = [0.00000001 * np.random.randn(dim)]
            
        self.symmetric = symmetric
        self.num_acceptances = 0    # use this to calculate acceptance rate
        self.acceptance_rate = 0
        
        # Handle both TargetDistribution and TorchTargetDistribution
        if target_dist is not None:
            if hasattr(target_dist, 'density'):
                self.target_density = target_dist.density
            else:
                # Fallback for objects that don't have density method
                self.target_density = None
        else:
            self.target_density = None

    def reset(self):
        """Reset the Markov chain to the initial state."""
        self.chain = [self.chain[0]]

    def step(self):
        """Take a step using the Metropolis-Hastings algorithm. Must be implemented in subclass."""
        raise NotImplementedError("Step method must be implemented in subclass")
    
    def get_curr_state(self):
        """Return the current state of the algorithm."""
        return self.chain[-1]
    
    def set_curr_state(self, state):
        """Set the current state of the algorithm."""
        self.chain[-1] = state

    def get_name(self):
        """Return the name of the algorithm as a string."""
        raise NotImplementedError("Subclasses must implement the get_name method.")

